{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/expr/","title":"API","text":""},{"location":"api/expr/#tick-expressions","title":"Tick Expressions","text":""},{"location":"api/expr/#activity","title":"Activity","text":""},{"location":"api/expr/#ffn_polars.expr.tick.activity.calc_burstiness","title":"<code>calc_burstiness(self, per='s')</code>","text":"<p>Calculates burstiness as std(inter-trade time) / mean(inter-trade time).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>timestamp column</p> required <code>per</code> <code>str</code> <p>time unit (\"s\", \"ms\", \"us\", \"ns\")</p> <code>'s'</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Float representing burstiness of trading activity.</p> Source code in <code>ffn_polars/expr/tick/activity.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@auto_alias(\"burstiness\")\ndef calc_burstiness(self: ExprOrStr, per: str = \"s\") -&gt; pl.Expr:\n    \"\"\"\n    Calculates burstiness as std(inter-trade time) / mean(inter-trade time).\n\n    Args:\n        self: timestamp column\n        per: time unit (\"s\", \"ms\", \"us\", \"ns\")\n\n    Returns:\n        Float representing burstiness of trading activity.\n    \"\"\"\n    scale = SCALE.get(per)\n    if scale is None:\n        raise ValueError(f\"Unsupported unit: {per}\")\n\n    itt_ns = self.diff().dt.total_nanoseconds()\n    return itt_ns.std().cast(pl.Float64) / itt_ns.mean().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.activity.calc_inter_trade_time","title":"<code>calc_inter_trade_time(self, per='s')</code>","text":"<p>Calculates the average time between consecutive trades.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>Timestamp column</p> required <code>per</code> <code>str</code> <p>Time unit \u2014 \"s\", \"ms\", \"us\", or \"ns\"</p> <code>'s'</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Float expression representing mean inter-trade time in desired unit</p> Example <p>df.group_by(\"ticker\").agg(     pl.col(\"timestamp\").calc_inter_trade_time(per=\"ms\") )</p> Source code in <code>ffn_polars/expr/tick/activity.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@auto_alias(\"inter_trade_time\")\ndef calc_inter_trade_time(self: ExprOrStr, per: str = \"s\") -&gt; pl.Expr:\n    \"\"\"\n    Calculates the average time between consecutive trades.\n\n    Args:\n        self: Timestamp column\n        per: Time unit \u2014 \"s\", \"ms\", \"us\", or \"ns\"\n\n    Returns:\n        Float expression representing mean inter-trade time in desired unit\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            pl.col(\"timestamp\").calc_inter_trade_time(per=\"ms\")\n        )\n    \"\"\"\n    scale = SCALE.get(per)\n    if scale is None:\n        raise ValueError(f\"Unsupported time unit: {per}\")\n\n    return self.diff().dt.total_nanoseconds().mean() / scale\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.activity.calc_trade_rate","title":"<code>calc_trade_rate(self, per='ms')</code>","text":"<p>Calculates trade rate as number of trades per second.</p> <p>Assumes <code>self</code> is a timestamp column from tick data.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>An expression representing trades per second:</p> <code>Expr</code> <p>(count of rows) / (max(timestamp) - min(timestamp)).seconds</p> Example <p>df.group_by(\"ticker\").agg(     pl.col(\"timestamp\").calc_trade_rate() )</p> Source code in <code>ffn_polars/expr/tick/activity.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@auto_alias(\"trade_rate\")\ndef calc_trade_rate(self: ExprOrStr, per: str = \"ms\") -&gt; pl.Expr:\n    \"\"\"\n    Calculates trade rate as number of trades per second.\n\n    Assumes `self` is a timestamp column from tick data.\n\n    Returns:\n        An expression representing trades per second:\n        (count of rows) / (max(timestamp) - min(timestamp)).seconds\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            pl.col(\"timestamp\").calc_trade_rate()\n        )\n    \"\"\"\n    scale = SCALE.get(per)\n    return pl.count().cast(pl.Float64) / (\n        (self.last() - self.first()).dt.total_nanoseconds() / scale\n    )\n</code></pre>"},{"location":"api/expr/#bars","title":"Bars","text":""},{"location":"api/expr/#direction","title":"Direction","text":""},{"location":"api/expr/#ffn_polars.expr.tick.direction.apply_tick_rule_to_volume","title":"<code>apply_tick_rule_to_volume(self, price)</code>","text":"<p>Applies the tick rule to volume data. Args:     self: Volume column     price: Price column Returns:     Volume with sign based on tick rule</p> Source code in <code>ffn_polars/expr/tick/direction.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@guard_expr(\"price\", expected_dtype=pl.Float64)\ndef apply_tick_rule_to_volume(self: ExprOrStr, price: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Applies the tick rule to volume data.\n    Args:\n        self: Volume column\n        price: Price column\n    Returns:\n        Volume with sign based on tick rule\n    \"\"\"\n    return self.cast(pl.Float64) * price.ffn.tick_rule()\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.direction.calc_tick_imbalance","title":"<code>calc_tick_imbalance(self)</code>","text":"<p>Calculates tick imbalance using signed volume.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>signed tick rule / direction column</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>Float between -1 and 1</p> Source code in <code>ffn_polars/expr/tick/direction.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"tick_imbalance\")\ndef calc_tick_imbalance(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates tick imbalance using signed volume.\n\n    Args:\n        self: signed tick rule / direction column\n\n    Returns:\n        Float between -1 and 1\n    \"\"\"\n    return self.sum().cast(pl.Float64) / self.len().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.direction.tick_rule","title":"<code>tick_rule(self)</code>","text":"Infers trade direction using the tick rule <p>+1 if price &gt; prev_price -1 if price &lt; prev_price  0 otherwise</p> Source code in <code>ffn_polars/expr/tick/direction.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"direction\")\ndef tick_rule(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Infers trade direction using the tick rule:\n        +1 if price &gt; prev_price\n        -1 if price &lt; prev_price\n         0 otherwise\n    \"\"\"\n    return (\n        pl.when(self &gt; self.shift(1))\n        .then(1)\n        .when(self &lt; self.shift(1))\n        .then(-1)\n        .otherwise(0)\n    )\n</code></pre>"},{"location":"api/expr/#flow","title":"Flow","text":""},{"location":"api/expr/#ffn_polars.expr.tick.flow.calc_order_flow_imbalance","title":"<code>calc_order_flow_imbalance(self)</code>","text":"<p>Calculates Order Flow Imbalance (OFI) as the sum of signed volume.</p> Assumes volume is signed <p>+V = buyer-initiated -V = seller-initiated</p> <p>Returns:</p> Type Description <code>Expr</code> <p>Float (positive = net buying, negative = net selling)</p> Example <p>df.group_by(\"ticker\").agg(     pl.col(\"signed_volume\").calc_order_flow_imbalance() )</p> Source code in <code>ffn_polars/expr/tick/flow.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"order_flow_imbalance\")\ndef calc_order_flow_imbalance(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates Order Flow Imbalance (OFI) as the sum of signed volume.\n\n    Assumes volume is signed:\n        +V = buyer-initiated\n        -V = seller-initiated\n\n    Returns:\n        Float (positive = net buying, negative = net selling)\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            pl.col(\"signed_volume\").calc_order_flow_imbalance()\n        )\n    \"\"\"\n    return self.sum().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.flow.calc_traded_value","title":"<code>calc_traded_value(self, volume)</code>","text":"<p>Calculates traded value (price \u00d7 volume sum).</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>Float column of trade prices</p> required <code>volume</code> <code>ExprOrStr</code> <p>Numeric column of trade volumes</p> required <p>Returns:</p> Name Type Description <code>Float</code> <code>Expr</code> <p>total traded value (dollar volume)</p> Example <p>df.group_by(\"ticker\").agg(     calc_traded_value(\"price\", \"volume\") )</p> Source code in <code>ffn_polars/expr/tick/flow.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"volume\", expected_dtype=pl.Float64)\n@auto_alias(\"traded_value\")\ndef calc_traded_value(self: ExprOrStr, volume: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates traded value (price \u00d7 volume sum).\n\n    Args:\n        self: Float column of trade prices\n        volume: Numeric column of trade volumes\n\n    Returns:\n        Float: total traded value (dollar volume)\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            calc_traded_value(\"price\", \"volume\")\n        )\n    \"\"\"\n    return (self * volume).sum().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.flow.calc_volume_rate","title":"<code>calc_volume_rate(self, ts, per='s')</code>","text":"<p>Calculates volume traded per unit time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>Numeric column of trade volumes</p> required <code>ts</code> <code>ExprOrStr</code> <p>Datetime column</p> required <code>per</code> <code>str</code> <p>\"s\", \"ms\", \"us\", or \"ns\" (default \"s\")</p> <code>'s'</code> <p>Returns:</p> Type Description <code>Expr</code> <p>Float expression representing volume per unit time</p> Example <p>df.group_by(\"ticker\").agg(     calc_volume_rate(\"volume\", \"timestamp\", per=\"ms\") )</p> Source code in <code>ffn_polars/expr/tick/flow.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Int64)\n@guard_expr(\"ts\", expected_dtype=pl.Datetime)\n@auto_alias(\"volume_rate\")\ndef calc_volume_rate(self: ExprOrStr, ts: ExprOrStr, per: str = \"s\") -&gt; pl.Expr:\n    \"\"\"\n    Calculates volume traded per unit time.\n\n    Args:\n        self: Numeric column of trade volumes\n        ts: Datetime column\n        per: \"s\", \"ms\", \"us\", or \"ns\" (default \"s\")\n\n    Returns:\n        Float expression representing volume per unit time\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            calc_volume_rate(\"volume\", \"timestamp\", per=\"ms\")\n        )\n    \"\"\"\n    scale = SCALE.get(per)\n    if scale is None:\n        raise ValueError(f\"Unsupported time unit: {per}\")\n\n    return self.sum().cast(pl.Float64) / (\n        (ts.max() - ts.min()).dt.total_nanoseconds() / scale\n    )\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.flow.calc_vwap","title":"<code>calc_vwap(self, volume)</code>","text":"<p>Calculates volume-weighted average price (VWAP).</p> Formula <p>VWAP = sum(price * volume) / sum(volume)</p> <p>Returns:</p> Type Description <code>Expr</code> <p>A float expression representing VWAP</p> Example <p>df.group_by(\"ticker\").agg(     calc_vwap(\"price\", \"volume\") )</p> Source code in <code>ffn_polars/expr/tick/flow.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"price\", expected_dtype=pl.Float64)\n@guard_expr(\"volume\", expected_dtype=pl.Float64)\n@auto_alias(\"vwap\")\ndef calc_vwap(self: ExprOrStr, volume: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates volume-weighted average price (VWAP).\n\n    Formula:\n        VWAP = sum(price * volume) / sum(volume)\n\n    Returns:\n        A float expression representing VWAP\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            calc_vwap(\"price\", \"volume\")\n        )\n    \"\"\"\n    return (self * volume).sum() / volume.sum().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#latency","title":"Latency","text":""},{"location":"api/expr/#price","title":"Price","text":""},{"location":"api/expr/#ffn_polars.expr.tick.price.calc_micro_returns","title":"<code>calc_micro_returns(self)</code>","text":"Calculates log returns at tick level <p>log(p_t) - log(p_{t-1})</p> <p>Returns:</p> Type Description <code>Expr</code> <p>Tick-level log return series</p> Source code in <code>ffn_polars/expr/tick/price.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"micro_returns\")\ndef calc_micro_returns(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates log returns at tick level:\n        log(p_t) - log(p_{t-1})\n\n    Returns:\n        Tick-level log return series\n    \"\"\"\n    return self.log() - self.log().shift(1)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.price.calc_price_impact","title":"<code>calc_price_impact(self, volume)</code>","text":"Calculates absolute price impact <p>(last price - first price) / sum(volume)</p> <p>Assumes volume is unsigned and price is a float column.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>Float representing absolute price impact per unit volume</p> Example <p>df.group_by(\"ticker\").agg(     calc_price_impact(\"price\", \"volume\") )</p> Source code in <code>ffn_polars/expr/tick/price.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"price\", expected_dtype=pl.Float64)\n@guard_expr(\"volume\", expected_dtype=pl.Float64)\n@auto_alias(\"price_impact\")\ndef calc_price_impact(self: ExprOrStr, volume: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates absolute price impact:\n        (last price - first price) / sum(volume)\n\n    Assumes volume is unsigned and price is a float column.\n\n    Returns:\n        Float representing absolute price impact per unit volume\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            calc_price_impact(\"price\", \"volume\")\n        )\n    \"\"\"\n    return (self.last() - self.first()) / volume.sum().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.tick.price.calc_price_volatility_ratio","title":"<code>calc_price_volatility_ratio(self)</code>","text":"Computes the coefficient of variation <p>std(price) / mean(price)</p> <p>Returns:</p> Name Type Description <code>Float</code> <code>Expr</code> <p>unitless relative volatility</p> Source code in <code>ffn_polars/expr/tick/price.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"price_volatility_ratio\")\ndef calc_price_volatility_ratio(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Computes the coefficient of variation:\n        std(price) / mean(price)\n\n    Returns:\n        Float: unitless relative volatility\n    \"\"\"\n    return self.std().cast(pl.Float64) / self.mean().cast(pl.Float64)\n</code></pre>"},{"location":"api/expr/#volatility","title":"Volatility","text":""},{"location":"api/expr/#ffn_polars.expr.tick.volatility.calc_realized_volatility","title":"<code>calc_realized_volatility(self)</code>","text":"<p>Calculates realized volatility (non-annualized) from a price series.</p> Formula <p>sqrt(\u03a3 (log(p_t) - log(p_{t-1}))^2)</p> <p>Assumes <code>self</code> is a price series. Use inside <code>.select()</code> or <code>.group_by().agg()</code>.</p> <p>Returns:</p> Type Description <code>Expr</code> <p>Realized volatility over the window</p> Example <p>df.group_by(\"ticker\").agg(     pl.col(\"price\").calc_realized_volatility() )</p> Source code in <code>ffn_polars/expr/tick/volatility.py</code> <pre><code>@register(namespace=\"tick\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"realized_volatility\")\ndef calc_realized_volatility(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates realized volatility (non-annualized) from a price series.\n\n    Formula:\n        sqrt(\u03a3 (log(p_t) - log(p_{t-1}))^2)\n\n    Assumes `self` is a price series. Use inside `.select()` or `.group_by().agg()`.\n\n    Returns:\n        Realized volatility over the window\n\n    Example:\n        df.group_by(\"ticker\").agg(\n            pl.col(\"price\").calc_realized_volatility()\n        )\n    \"\"\"\n    log_returns = self.log() - self.log().shift(1)\n    return (log_returns**2).sum().sqrt()\n</code></pre>"},{"location":"api/expr/#eod-expressions","title":"EOD Expressions","text":""},{"location":"api/expr/#ratios","title":"Ratios","text":""},{"location":"api/expr/#ffn_polars.expr.eod.ratios.calc_calmar_ratio","title":"<code>calc_calmar_ratio(self, date_col)</code>","text":"<p>Returns a Polars expression to compute the Calmar ratio: CAGR / |Max Drawdown|</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>Column name of price series</p> required <code>date_col</code> <code>str</code> <p>Column name of date series</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>pl.Expr: Calmar ratio expression</p> Source code in <code>ffn_polars/expr/eod/ratios.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"calmar_ratio\")\ndef calc_calmar_ratio(self: ExprOrStr, date_col: str) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression to compute the Calmar ratio: CAGR / |Max Drawdown|\n\n    Args:\n        self: Column name of price series\n        date_col: Column name of date series\n\n    Returns:\n        pl.Expr: Calmar ratio expression\n    \"\"\"\n    cagr_expr = self.ffn.calc_cagr(date_col=date_col)\n    max_dd_expr = self.ffn.calc_max_drawdown().abs()\n\n    return cagr_expr / max_dd_expr\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.ratios.calc_information_ratio","title":"<code>calc_information_ratio(self, benchmark)</code>","text":"<p>Returns a Polars expression that computes the Information Ratio.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>name of the column with asset returns</p> required <code>benchmark</code> <code>ExprOrStr</code> <p>name of the column with benchmark returns</p> required Source code in <code>ffn_polars/expr/eod/ratios.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"benchmark\", expected_dtype=pl.Float64)\n@auto_alias(\"ir\")\ndef calc_information_ratio(self: ExprOrStr, benchmark: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression that computes the Information Ratio.\n\n    Args:\n        self: name of the column with asset returns\n        benchmark: name of the column with benchmark returns\n    \"\"\"\n    diff = self - benchmark\n\n    return (diff.mean() / diff.std(ddof=1)).fill_nan(0.0).fill_null(0.0)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.ratios.calc_prob_mom","title":"<code>calc_prob_mom(self, b)</code>","text":"<p>Polars expression that computes probabilistic momentum between two return columns. If Rust plugin is available, uses it. Otherwise, falls back to a Polars map_batches version.</p> Source code in <code>ffn_polars/expr/eod/ratios.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"b\", expected_dtype=pl.Float64)\n@auto_alias(\"prob_mom\")\ndef calc_prob_mom(self: ExprOrStr, b: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Polars expression that computes probabilistic momentum between two return columns.\n    If Rust plugin is available, uses it. Otherwise, falls back to a Polars map_batches version.\n    \"\"\"\n\n    name1 = self.meta.output_name()\n    name2 = b.meta.output_name()\n    if _HAS_RUST:\n        return pl.struct([name1, name2]).map_batches(\n            lambda s: _rust.prob_mom(s.struct.field(name1), s.struct.field(name2)),\n            return_dtype=pl.Float64,\n        )\n\n    # fallback: pure Polars map\n    diff = self - b\n    ir = (diff.mean() / diff.std()).alias(\"information_ratio\")\n    n = pl.count().alias(\"n_obs\")\n\n    return (\n        pl.struct([ir, n])\n        .map_batches(\n            lambda s: pl.Series([_prob_mom_cdf(s[0])]),\n            return_dtype=pl.Float64,\n        )\n        .alias(\"prob_momentum\")\n    )\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.ratios.calc_risk_return_ratio","title":"<code>calc_risk_return_ratio(self)</code>","text":"<p>Calculates the return / risk ratio. Basically the <code>Sharpe ratio &lt;https://www.investopedia.com/terms/s/sharperatio.asp&gt;</code> without factoring in the <code>risk-free rate &lt;https://www.investopedia.com/terms/r/risk-freerate.asp&gt;</code>.</p> Source code in <code>ffn_polars/expr/eod/ratios.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"risk_return_ratio\")\ndef calc_risk_return_ratio(self) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the return / risk ratio. Basically the\n    `Sharpe ratio &lt;https://www.investopedia.com/terms/s/sharperatio.asp&gt;`_ without factoring in the `risk-free rate &lt;https://www.investopedia.com/terms/r/risk-freerate.asp&gt;`_.\n    \"\"\"\n    return calc_sharpe(self)\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.ratios.calc_sharpe","title":"<code>calc_sharpe(self, rf=0.0, n=252, annualize=True)</code>","text":"<p>Polars expression that computes the Sharpe ratio in-place without aliasing.</p> Source code in <code>ffn_polars/expr/eod/ratios.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"sharpe\")\ndef calc_sharpe(\n    self: str,\n    rf: Union[float, str] = 0.0,\n    n: int = 252,\n    annualize: bool = True,\n) -&gt; pl.Expr:\n    \"\"\"\n    Polars expression that computes the Sharpe ratio in-place without aliasing.\n    \"\"\"\n    excess_expr = self.ffn.to_excess_returns(rf, n)\n\n    sharpe_expr = (\n        (excess_expr.mean() / excess_expr.std(ddof=1)) * math.sqrt(n)\n        if annualize\n        else (excess_expr.mean() / excess_expr.std(ddof=1))\n    )\n\n    return sharpe_expr\n</code></pre>"},{"location":"api/expr/#returns","title":"Returns","text":""},{"location":"api/expr/#ffn_polars.expr.eod.returns.calc_cagr","title":"<code>calc_cagr(self, date_col)</code>","text":"<p>Calculates the <code>CAGR (compound annual growth rate) &lt;https://www.investopedia.com/terms/c/cagr.asp&gt;</code>_ for a given price series.</p> <p>Returns:</p> Type Description <code>Expr</code> <ul> <li>float -- cagr.</li> </ul> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@guard_expr(\"date_col\", expected_dtype=pl.Datetime)\n@auto_alias(\"cagr\")\ndef calc_cagr(self: ExprOrStr, date_col: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the `CAGR (compound annual growth rate) &lt;https://www.investopedia.com/terms/c/cagr.asp&gt;`_ for a given price series.\n\n    Returns:\n        * float -- cagr.\n\n    \"\"\"\n    return (self.last() / self.first()) ** (1 / date_col.ffn.year_frac()) - 1\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.calc_mtd","title":"<code>calc_mtd(self, date_col='Date')</code>","text":"<p>Calculate Month-To-Date return using daily prices only.</p> <p>Logic: - Latest price = last row - Reference price = last price from previous month - MTD = (latest / reference) - 1</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"date_col\", expected_dtype=pl.Datetime)\n@auto_alias(\"mtd\")\ndef calc_mtd(self: pl.Expr, date_col: ExprOrStr = \"Date\") -&gt; pl.Expr:\n    \"\"\"\n    Calculate Month-To-Date return using daily prices only.\n\n    Logic:\n    - Latest price = last row\n    - Reference price = last price from previous month\n    - MTD = (latest / reference) - 1\n    \"\"\"\n    prices = self\n    latest_date = date_col.max()\n\n    # Extract month &amp; year\n    latest_month = latest_date.dt.month()\n    latest_year = latest_date.dt.year()\n\n    return pl.when(True).then(\n        prices.filter(\n            (date_col.dt.month() != latest_month) | (date_col.dt.year() != latest_year)\n        )\n        .last()\n        .pipe(lambda ref: prices.last() / ref - 1)\n    )\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.calc_total_return","title":"<code>calc_total_return(self)</code>","text":"<p>Calculates the total return of a series.</p> <p>last / first - 1</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"total_return\")\ndef calc_total_return(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the total return of a series.\n\n    last / first - 1\n    \"\"\"\n    return (self.last() / self.first()) - 1\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.calc_ytd","title":"<code>calc_ytd(self, date_col='Date')</code>","text":"<p>Calculate Year-To-Date (YTD) return using daily prices.</p> <p>Logic: - Identify current year from latest date - First price = first row of current year - Latest price = most recent row - YTD = (latest / first_of_year) - 1</p> <p>Assumes <code>date_col</code> is sorted ascending.</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@auto_alias(\"ytd\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"date_col\", expected_dtype=pl.Datetime)\ndef calc_ytd(self: pl.Expr, date_col: ExprOrStr = \"Date\") -&gt; pl.Expr:\n    \"\"\"\n    Calculate Year-To-Date (YTD) return using daily prices.\n\n    Logic:\n    - Identify current year from latest date\n    - First price = first row of current year\n    - Latest price = most recent row\n    - YTD = (latest / first_of_year) - 1\n\n    Assumes `date_col` is sorted ascending.\n    \"\"\"\n\n    latest_date_expr = date_col.max()\n    current_year = latest_date_expr.dt.year()\n\n    # Filter to current year only\n    current_year_prices = self.filter(date_col.dt.year() == current_year)\n\n    return (current_year_prices.last() / current_year_prices.first()) - 1\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.rebase","title":"<code>rebase(self, value=100)</code>","text":"<p>Rebase a price series to a given value.</p> <p>Formula is: (p / p0) * value</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"rebased\")\ndef rebase(self, value=100):\n    \"\"\"\n    Rebase a price series to a given value.\n\n    Formula is: (p / p0) * value\n    \"\"\"\n    return self / self.first() * value\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.to_excess_returns","title":"<code>to_excess_returns(self, rf, n)</code>","text":"<p>Returns a Polars expression that computes excess returns.</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"excess\")\ndef to_excess_returns(self: ExprOrStr, rf: Union[float, str], n: int) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression that computes excess returns.\n\n    \"\"\"\n    if isinstance(rf, float):\n        if rf == 0:\n            return self\n        else:\n            return self - ((1 + rf) ** (1 / n) - 1)\n    elif isinstance(rf, str):\n        return self - pl.col(rf)\n    else:\n        raise TypeError(\"rf must be either a float or a column name string\")\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.to_log_returns","title":"<code>to_log_returns(self)</code>","text":"<p>Calculates the log returns of a price series.</p> <p>Formula is: ln(p1/p0)</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"log_returns\")\ndef to_log_returns(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the log returns of a price series.\n\n    Formula is: ln(p1/p0)\n\n    \"\"\"\n    return (self / self.shift(1)).log()\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.to_price_index","title":"<code>to_price_index(self, start=100)</code>","text":"<p>Returns a price index given a series of returns.</p> <p>Assumes arithmetic returns.</p> <p>Formula is: cumprod (1+r)</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64, required_substring=\"returns\")\n@auto_alias(\"price_index\")\ndef to_price_index(self, start=100):\n    \"\"\"\n    Returns a price index given a series of returns.\n\n    Assumes arithmetic returns.\n\n    Formula is: cumprod (1+r)\n    \"\"\"\n    return (self.fill_null(0.0) + 1).cum_prod() * start\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.returns.to_returns","title":"<code>to_returns(self)</code>","text":"<p>Calculates the simple arithmetic returns of a price series.</p> <p>Formula is: (t1 / t0) - 1</p> Source code in <code>ffn_polars/expr/eod/returns.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"returns\")\ndef to_returns(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the simple arithmetic returns of a price series.\n\n    Formula is: (t1 / t0) - 1\n\n    \"\"\"\n    return self / self.shift(1) - 1\n</code></pre>"},{"location":"api/expr/#risk","title":"Risk","text":""},{"location":"api/expr/#ffn_polars.expr.eod.risk.calc_max_drawdown","title":"<code>calc_max_drawdown(self)</code>","text":"<p>Calculates the max drawdown of a price series. If you want the actual drawdown series, please use to_drawdown_series.</p> Source code in <code>ffn_polars/expr/eod/risk.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"max_drawdown\")\ndef calc_max_drawdown(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the max drawdown of a price series. If you want the\n    actual drawdown series, please use to_drawdown_series.\n    \"\"\"\n    return self.ffn.to_drawdown_series().min()\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.risk.to_drawdown_series","title":"<code>to_drawdown_series(self)</code>","text":"<p>Calculates the <code>drawdown &lt;https://www.investopedia.com/terms/d/drawdown.asp&gt;</code>_ series.</p> <p>This returns a series representing a drawdown. When the price is at all time highs, the drawdown is 0. However, when prices are below high water marks, the drawdown series = current / hwm - 1</p> <p>The max drawdown can be obtained by simply calling .min() on the result (since the drawdown series is negative)</p> <p>Method ignores all gaps of NaN's in the price series.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>prices</p> required Source code in <code>ffn_polars/expr/eod/risk.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"drawdowns\")\ndef to_drawdown_series(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Calculates the `drawdown &lt;https://www.investopedia.com/terms/d/drawdown.asp&gt;`_ series.\n\n    This returns a series representing a drawdown.\n    When the price is at all time highs, the drawdown\n    is 0. However, when prices are below high water marks,\n    the drawdown series = current / hwm - 1\n\n    The max drawdown can be obtained by simply calling .min()\n    on the result (since the drawdown series is negative)\n\n    Method ignores all gaps of NaN's in the price series.\n\n    Args:\n        self: prices\n\n    \"\"\"\n    prices_clean = self.forward_fill()\n    hwm = prices_clean.cum_max()\n    return prices_clean / hwm - 1\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.risk.ulcer_index","title":"<code>ulcer_index(self)</code>","text":"<p>Returns a Polars expression to compute the Ulcer Index from a price series.</p> Formula <ol> <li>Compute cumulative max of prices.</li> <li>Calculate drawdowns: ((price - cummax) / cummax) * 100.</li> <li>Square drawdowns, take mean, then square root.</li> </ol> Source code in <code>ffn_polars/expr/eod/risk.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"ulcer_index\")\ndef ulcer_index(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression to compute the Ulcer Index from a price series.\n\n    Formula:\n        1. Compute cumulative max of prices.\n        2. Calculate drawdowns: ((price - cummax) / cummax) * 100.\n        3. Square drawdowns, take mean, then square root.\n    \"\"\"\n    cummax = self.cum_max()\n    drawdown_pct = ((self - cummax) / cummax) * 100\n    squared_drawdowns = drawdown_pct.pow(2)\n\n    return squared_drawdowns.mean().sqrt()\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.risk.ulcer_performance_index","title":"<code>ulcer_performance_index(self, rf=0.0, n=None)</code>","text":"<p>Returns a Polars expression to compute Ulcer Performance Index (UPI).</p> <p>UPI = mean(excess returns) / ulcer index Must be used inside <code>.select()</code> or <code>.with_columns()</code></p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>column with prices</p> required <code>rf</code> <code>Union[float, str]</code> <p>either a float (annualized) or a column name containing RF series</p> <code>0.0</code> <code>n</code> <code>int</code> <p>required if rf is float and nonzero</p> <code>None</code> Source code in <code>ffn_polars/expr/eod/risk.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"ulcer_performance_index\")\ndef ulcer_performance_index(\n    self: ExprOrStr, rf: Union[float, str] = 0.0, n: int = None\n) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression to compute Ulcer Performance Index (UPI).\n\n    UPI = mean(excess returns) / ulcer index\n    Must be used inside `.select()` or `.with_columns()`\n\n    Args:\n        self: column with prices\n        rf: either a float (annualized) or a column name containing RF series\n        n: required if rf is float and nonzero\n    \"\"\"\n    if isinstance(rf, float):\n        if rf != 0 and n is None:\n            raise ValueError(\"nperiods must be set when rf is a non-zero float\")\n\n        excess_returns = self.ffn.to_returns() - (rf / n if rf != 0 else 0)\n\n    elif isinstance(rf, str):\n        # Subtract column rf from returns\n        excess_returns = self.ffn.to_returns() - pl.col(rf)\n    else:\n        raise TypeError(\"rf must be a float or a string (column name)\")\n\n    return excess_returns.mean() / self.ffn.ulcer_index()\n</code></pre>"},{"location":"api/expr/#temporal","title":"Temporal","text":""},{"location":"api/expr/#ffn_polars.expr.eod.temporal.annualize","title":"<code>annualize(self, durations, one_year=365.0)</code>","text":"<p>Returns a Polars expression to annualize returns given durations.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>Name of the column with returns (e.g., 0.05 = 5%).</p> required <code>durations</code> <code>ExprOrStr</code> <p>Name of the column with durations (e.g., days held).</p> required <code>one_year</code> <code>float</code> <p>Number of periods in a year (default 365.0 for days).</p> <code>365.0</code> <p>Returns:</p> Type Description <code>Expr</code> <p>pl.Expr: Expression computing annualized return.</p> Source code in <code>ffn_polars/expr/eod/temporal.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@guard_expr(\"durations\", expected_dtype=pl.Float64)\n@auto_alias(\"annualized\")\ndef annualize(\n    self: ExprOrStr, durations: ExprOrStr, one_year: float = 365.0\n) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression to annualize returns given durations.\n\n    Args:\n        self: Name of the column with returns (e.g., 0.05 = 5%).\n        durations: Name of the column with durations (e.g., days held).\n        one_year: Number of periods in a year (default 365.0 for days).\n\n    Returns:\n        pl.Expr: Expression computing annualized return.\n    \"\"\"\n    return (1.0 + self) ** (one_year / durations) - 1.0\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.temporal.deannualize","title":"<code>deannualize(self, n)</code>","text":"<p>Returns a Polars expression that converts annualized returns to periodic returns.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>ExprOrStr</code> <p>column containing annualized returns</p> required <code>n</code> <code>int</code> <p>Number of periods per year (e.g., 252 for daily)</p> required Source code in <code>ffn_polars/expr/eod/temporal.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Float64)\n@auto_alias(\"deannualized\")\ndef deannualize(self: ExprOrStr, n: int) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression that converts annualized returns to periodic returns.\n\n    Args:\n        self: column containing annualized returns\n        n: Number of periods per year (e.g., 252 for daily)\n    \"\"\"\n    return (self + 1.0) ** (1.0 / n) - 1.0\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.temporal.infer_freq","title":"<code>infer_freq(self)</code>","text":"<p>Infers human-readable calendar frequency label from a datetime column. Works best for: yearly, quarterly, monthly, weekly, daily.</p> <p>Returns: \"yearly\", \"quarterly\", \"monthly\", \"weekly\", \"daily\", or None</p> Source code in <code>ffn_polars/expr/eod/temporal.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"date_col\", expected_dtype=pl.Datetime)\n@auto_alias(\"inferred_freq\")\ndef infer_freq(self: ExprOrStr) -&gt; pl.Expr:\n    \"\"\"\n    Infers human-readable calendar frequency label from a datetime column.\n    Works best for: yearly, quarterly, monthly, weekly, daily.\n\n    Returns: \"yearly\", \"quarterly\", \"monthly\", \"weekly\", \"daily\", or None\n    \"\"\"\n    deltas = (\n        (\n            self.cast(pl.Datetime).sort().diff().dt.total_nanoseconds().cast(pl.Float64)\n            / 86400\n            / 1_000_000_000\n        )  # convert to float days\n        .drop_nulls()\n        .alias(\"delta_days\")\n    )\n\n    std_expr = deltas.std().alias(\"delta_std\")\n    mode_expr = deltas.mode().first().alias(\"mode_days\")\n\n    return (\n        pl.struct(\n            [\n                std_expr,\n                mode_expr,\n            ]\n        )\n        .map_batches(_map_mode_days_with_tolerance, return_dtype=pl.Utf8)\n        .alias(\"freq\")\n    )\n</code></pre>"},{"location":"api/expr/#ffn_polars.expr.eod.temporal.year_frac","title":"<code>year_frac(self)</code>","text":"<p>Returns a Polars expression that computes the year fraction between the first and last date in a column, assuming average year length (365.25 days = 31557600 seconds).</p> Source code in <code>ffn_polars/expr/eod/temporal.py</code> <pre><code>@register(namespace=\"eod\")\n@guard_expr(\"self\", expected_dtype=pl.Datetime)\n@auto_alias(\"year_frac\")\ndef year_frac(self) -&gt; pl.Expr:\n    \"\"\"\n    Returns a Polars expression that computes the year fraction between the first and last date\n    in a column, assuming average year length (365.25 days = 31557600 seconds).\n    \"\"\"\n    return (\n        self.cast(pl.Datetime).last() - self.cast(pl.Datetime).first()\n    ).dt.total_seconds() / 31_557_600\n</code></pre>"},{"location":"api/expr/#main-namespace-registry","title":"Main Namespace Registry","text":""}]}